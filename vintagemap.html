<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vintage Strava Route Maps</title>
  <link rel="preconnect" href="https://cdn.maptiler.com">
  <link rel="dns-prefetch" href="https://api.maptiler.com">
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.2.2/maptiler-sdk.umd.min.js"></script>
  <link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.2.2/maptiler-sdk.css" rel="stylesheet">
  <style>
    body { margin: 0; padding: 20px; font-family: Georgia, serif; background: #f4e4c1; }
    h1 { text-align: center; color: #654321; margin-bottom: 10px; }
    .upload { text-align: center; padding: 20px; background: white; border: 2px solid #8b4513; border-radius: 8px; margin-bottom: 20px; position: relative; }
    input[type="file"] { padding: 10px; border: 2px solid #8b4513; border-radius: 8px; font-size: 16px; }
    .btn { padding: 10px 20px; background: #8b4513; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: Georgia, serif; margin: 0 5px; }
    .btn:hover { background: #654321; }
    .btn.strava { background: #FC4C02; }
    .btn.strava:hover { background: #e03e00; }
    .loading { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #8b4513; border-radius: 5px; z-index: 1000; }
    .loading.active { display: block; }
    #map { width: 100%; height: calc(100vh - 180px); border: 4px solid #8b4513; border-radius: 8px; position: relative; }
    
    /* Map buttons - moved to LEFT side, upper position */
    .map-btn { position: absolute; left: 10px; z-index: 1000; padding: 10px 20px; background: #8b4513; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: Georgia, serif; font-size: 14px; }
    .map-btn:hover { background: #654321; }
    #fullscreenBtn { top: 10px; }
    #toggleElevation { top: 60px; }
    #toggleStats { top: 110px; }
    #toggleLabels { top: 160px; }
    #toggleMapStyle { top: 210px; }

    .vintage-terrain-toggle {
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.95);
    }

    .terrain-toggle-button {
      width: 32px;
      height: 32px;
      font-family: Georgia, serif;
      font-weight: bold;
      font-size: 14px;
      border: none;
      background: rgba(255, 255, 255, 0.95);
      color: #654321;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .terrain-toggle-button:hover,
    .terrain-toggle-button.is-active {
      background: #8b4513;
      color: #ffffff;
    }

    .terrain-toggle-button:focus {
      outline: 2px solid #8b4513;
      outline-offset: 1px;
    }

    #trailLabels { position: absolute; top: 210px; right: 20px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 15px; border: 2px solid #8b4513; border-radius: 8px; max-width: 300px; max-height: 400px; overflow-y: auto; display: none; }
    .trail-label-item { margin: 5px 0; padding: 8px; background: #f9f9f9; border: 1px solid #8b4513; border-radius: 5px; font-size: 12px; }
    #stats { position: absolute; bottom: 20px; left: 20px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 15px 20px; border: 2px solid #8b4513; border-radius: 8px; font-size: 14px; width: 280px; display: none; }
    #stats h3 { margin: 0 0 10px 0; color: #654321; }
    #stats .stat-line { margin: 5px 0; color: #654321; }
    
    /* Enhanced elevation profile - full width with proper sizing */
    #elevationProfile { position: absolute; bottom: 20px; right: 20px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 20px; border: 2px solid #8b4513; border-radius: 8px; width: 600px; display: none; }
    #elevationProfile h3 { margin: 0 0 15px 0; color: #654321; font-size: 16px; }
    #elevationCanvas { width: 100%; height: 200px; background: #f9f9f9; border: 1px solid #8b4513; display: block; }
    
    .strava-section { margin-top: 20px; padding-top: 20px; border-top: 2px solid #8b4513; }
    #activitySelector { display: none; margin-top: 20px; }
    #dateRangeSelector { margin-bottom: 15px; padding: 10px; background: #f9f9f9; border: 1px solid #8b4513; border-radius: 5px; }
    #activityList { max-height: 300px; overflow-y: auto; border: 1px solid #8b4513; padding: 10px; background: white; border-radius: 5px; }
    .activity-item { margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: #f9f9f9; }
    .activity-item:hover { background: #f0f0f0; }
    .activity-item label { display: flex; align-items: center; cursor: pointer; }
    .activity-item input { margin-right: 10px; }
    @media (max-width: 768px) {
      .map-btn { padding: 12px 24px; font-size: 16px; }
      #elevationProfile { width: 90%; right: 5%; }
      #stats { width: 90%; left: 5%; }
    }
  </style>
</head>
<body>
  <h1>üó∫Ô∏è Vintage Strava Route Maps</h1>
  <p style="text-align:center;color:#654321;">Upload GPX files or connect to Strava</p>
  
  <div class="upload">
    <div>
      <input type="file" id="gpxInput" accept=".gpx" multiple>
      <button class="btn" id="clearBtn">Clear All</button>
    </div>
    
    <div class="strava-section">
      <h3 style="color: #654321;">Connect to Strava</h3>
      <div id="stravaButtons"></div>
    </div>
    
    <div id="activitySelector">
      <div id="dateRangeSelector">
        <h4 style="color: #654321;">Select Date Range</h4>
        <label>From: <input type="date" id="startDate"></label>
        <label style="margin-left: 15px;">To: <input type="date" id="endDate"></label>
        <button class="btn" id="loadDateRange">Load Activities</button>
      </div>
      <div id="activitySummary"></div>
      <div id="activityList">Loading...</div>
      <div style="margin-top: 10px; text-align: center;">
        <button class="btn" id="loadSelected">Load Selected</button>
        <button class="btn" id="selectAll">Select All</button>
        <button class="btn" id="selectNone">Select None</button>
      </div>
    </div>
  </div>
  
  <div class="loading" id="loadingIndicator">Processing...</div>
  
  <div id="map">
    <!-- Buttons now on LEFT side -->
    <button id="fullscreenBtn" class="map-btn">‚õ∂ Fullscreen</button>
    <button id="toggleElevation" class="map-btn">üìà Elevation</button>
    <button id="toggleStats" class="map-btn">üìä Statistics</button>
    <button id="toggleLabels" class="map-btn">üè∑Ô∏è Labels</button>
    <button id="toggleMapStyle" class="map-btn">üó∫Ô∏è Streets</button>
    
    <div id="stats">
      <h3>Route Statistics</h3>
      <div id="statsContent"></div>
    </div>
    <div id="elevationProfile">
      <h3>Elevation Profile</h3>
      <canvas id="elevationCanvas"></canvas>
    </div>
    <div id="trailLabels">
      <div id="trailLabelsContent"></div>
    </div>
  </div>
  
  <script>
'use strict';

const StravaMapApp = (function() {
  // ============================================
  // CONFIGURATION
  // ============================================
  const CONFIG = {
    MAX_FILES: 20,
    MAX_ROUTES: 100,
    COLORS: ['#8b4513', '#2d5016', '#8b0000', '#4a5d23', '#704214'],
    API_KEY: '5PL6GenHHg90wGEdaexX',
    
    // FIX #1: Use valid public MapTiler styles
    // The custom style ID was not accessible - replaced with public styles
    MAP_STYLES: {
      streets: 'https://api.maptiler.com/maps/streets/style.json?key=5PL6GenHHg90wGEdaexX',
      vintage: 'https://api.maptiler.com/maps/01997ab7-a217-795c-8aa0-35f8e9dcdc74/style.json?key=5PL6GenHHg90wGEdaexX',
      satellite: 'https://api.maptiler.com/maps/hybrid/style.json?key=5PL6GenHHg90wGEdaexX',
      topo: 'https://api.maptiler.com/maps/outdoor/style.json?key=5PL6GenHHg90wGEdaexX'
    },
    TERRAIN: {
      sourceId: 'terrain-dem',
      sourceUrl: 'https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=5PL6GenHHg90wGEdaexX',
      exaggeration: 1.5
    },

    EARTH_RADIUS: 6371
  };
  
  // ============================================
  // STATE MANAGEMENT
  // ============================================
  const state = {
    map: null,
    fileData: [],
    routes: [],
    stats: {
      totalDistance: 0,
      totalClimb: 0,
      totalDescent: 0,
      startDate: null,
      endDate: null,
      days: new Set()
    },
    colorIndex: 0,
    stravaConnected: false,
    stravaActivities: [],
    currentMapStyle: 'streets', // Start with streets, can toggle to vintage/satellite/topo
    terrainToggleControl: null,
    terrainEnabled: false
  };
  
  const elements = {};
  
  // ============================================
  // GPX PARSER
  // ============================================
  class GPXParser {
    constructor(xml, filename) {
      this.xml = xml;
      this.filename = filename;
      this.data = {
        coordinates: [],
        elevations: [],
        profile: [],
        trackPoints: [],
        totalDistance: 0,
        climb: 0,
        descent: 0,
        startTime: null,
        startDate: null,
        endDate: null,
        startElevation: null,
        endElevation: null,
        name: filename
      };
    }
    
    parse() {
      const trackPoints = this.xml.getElementsByTagName('trkpt');
      if (trackPoints.length === 0) {
        throw new Error('No track points found');
      }
      
      let prevLat = null;
      let prevLon = null;
      let prevElevation = null;
      let cumulativeDistance = 0;

      // Extract coordinates and elevation data
      for (let i = 0; i < trackPoints.length; i++) {
        const point = trackPoints[i];
        const lat = parseFloat(point.getAttribute('lat'));
        const lon = parseFloat(point.getAttribute('lon'));

        if (Number.isFinite(lat) && Number.isFinite(lon)) {
          if (prevLat !== null && prevLon !== null) {
            const segmentDistance = this.calculateDistance(prevLat, prevLon, lat, lon);
            if (Number.isFinite(segmentDistance)) {
              cumulativeDistance += segmentDistance;
            }
          }

          this.data.coordinates.push([lon, lat]);

          let elevationValue = null;
          const elevationElement = this.findElevationElement(point);
          if (elevationElement) {
            const ele = parseFloat(elevationElement.textContent);
            if (Number.isFinite(ele)) {
              elevationValue = ele;
              this.data.elevations.push(ele);
              this.data.profile.push({
                distance: cumulativeDistance,
                elevation: ele
              });

              if (prevElevation !== null) {
                const diff = ele - prevElevation;
                if (diff > 0) {
                  this.data.climb += diff;
                } else if (diff < 0) {
                  this.data.descent += Math.abs(diff);
                }
              }

              prevElevation = ele;
            }
          }

          this.data.trackPoints.push({
            distance: cumulativeDistance,
            elevation: Number.isFinite(elevationValue) ? elevationValue : null,
            coordinates: [lon, lat]
          });

          const timeElement = point.getElementsByTagName('time')[0];
          if (timeElement) {
            const date = new Date(timeElement.textContent);
            if (!isNaN(date)) {
              const timeStr = date.toISOString().split('T')[0];
              if (!this.data.startDate) {
                this.data.startDate = timeStr;
                this.data.startTime = date.toISOString();
              }
              this.data.endDate = timeStr;
            }
          }

          prevLat = lat;
          prevLon = lon;
        }
      }

      this.data.totalDistance = cumulativeDistance;

      if (this.data.profile.length > 0) {
        this.data.startElevation = this.data.profile[0].elevation;
        this.data.endElevation = this.data.profile[this.data.profile.length - 1].elevation;
      }

      return this.data;
    }

    findElevationElement(point) {
      if (!point || typeof point.getElementsByTagName !== 'function') {
        return null;
      }

      const direct = point.getElementsByTagName('ele');
      if (direct && direct.length > 0) {
        return direct[0];
      }

      const altTags = ['gpxtpx:AltitudeMeters', 'gpxtpx:altitude', 'gpxtpx:Altitude'];
      for (const tag of altTags) {
        const elements = point.getElementsByTagName(tag);
        if (elements && elements.length > 0) {
          return elements[0];
        }

        if (typeof point.getElementsByTagNameNS === 'function') {
          const [prefix, local] = tag.split(':');
          const namespace = point.lookupNamespaceURI(prefix);
          if (namespace) {
            const nsElements = point.getElementsByTagNameNS(namespace, local);
            if (nsElements && nsElements.length > 0) {
              return nsElements[0];
            }
          }
        }
      }

      const children = point.getElementsByTagName('*');
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child && child.localName) {
          const name = child.localName.toLowerCase();
          if (name === 'altitudemeters' || name === 'altitude' || name === 'ele') {
            return child;
          }
        }
      }

      return null;
    }

    /**
     * Haversine formula for calculating distance between two GPS coordinates
     */
    calculateDistance(lat1, lon1, lat2, lon2) {
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
      return CONFIG.EARTH_RADIUS * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
  }
  
  // ============================================
  // STRAVA INTEGRATION
  // ============================================
  
  /**
   * Load selected Strava activities sequentially
   * Prevents API overload by adding delays between requests
   */
  async function loadSelectedActivities() {
    const checkboxes = document.querySelectorAll('#activityList input:checked');
    if (checkboxes.length === 0) {
      alert('Please select at least one activity');
      return;
    }
    
    elements.loadingIndicator.classList.add('active');
    elements.loadingIndicator.textContent = `Loading 0/${checkboxes.length} activities...`;
    
    let loaded = 0;
    let failed = 0;
    
    // Process activities one by one with delay to prevent API throttling
    for (let i = 0; i < checkboxes.length; i++) {
      const checkbox = checkboxes[i];
      
      try {
        elements.loadingIndicator.textContent = `Loading ${i + 1}/${checkboxes.length} activities...`;
        
        const response = await fetch(`strava-gpx.php?id=${checkbox.value}`, {
          credentials: 'same-origin'
        });
        
        if (!response.ok) throw new Error('Failed to load GPX');
        
        const gpxText = await response.text();
        
        // Validate GPX data
        if (!gpxText.includes('<gpx') || gpxText.includes('error')) {
          throw new Error('Invalid GPX data received');
        }
        
        const xml = new DOMParser().parseFromString(gpxText, 'text/xml');
        
        // Check for XML parsing errors
        const parserError = xml.querySelector('parsererror');
        if (parserError) {
          throw new Error('GPX parsing failed');
        }
        
        const parser = new GPXParser(xml, checkbox.dataset.name);
        const data = parser.parse();
        
        if (data.coordinates.length > 0) {
          addRouteToMap(data);
          loaded++;
        }
        
        // Add delay between requests to prevent API throttling
        await new Promise(resolve => setTimeout(resolve, 500));
        
      } catch (error) {
        console.error('Failed to load activity:', checkbox.dataset.name, error);
        failed++;
      }
    }
    
    elements.loadingIndicator.classList.remove('active');
    elements.activitySelector.style.display = 'none';
    
    const message = failed > 0 
      ? `Loaded ${loaded} activities, ${failed} failed` 
      : `Successfully loaded ${loaded} activities`;
    alert(message);
  }

  /**
   * Load activities within a specified date range from Strava
   */
  async function loadActivitiesForDateRange() {
    const startDate = new Date(elements.startDate.value);
    const endDate = new Date(elements.endDate.value);
    
    // Validate date inputs
    if (!elements.startDate.value || !elements.endDate.value) {
      alert('Please select both start and end dates');
      return;
    }
    
    if (startDate > endDate) {
      alert('Start date must be before end date');
      return;
    }
    
    elements.loadingIndicator.classList.add('active');
    elements.activityList.innerHTML = 'Loading activities...';
    
    try {
      // Convert JavaScript dates to Unix timestamps (Strava API requirement)
      const after = Math.floor(startDate.getTime() / 1000);
      const before = Math.floor(endDate.getTime() / 1000) + 86400; // +1 day to include end date
      
      const response = await fetch(`strava-activities.php?after=${after}&before=${before}&per_page=200`, {
        credentials: 'same-origin'
      });
      
      if (!response.ok) {
        throw new Error('Failed to load activities');
      }
      
      const activities = await response.json();
      activities.sort((a, b) => new Date(a.start_date) - new Date(b.start_date));
      state.stravaActivities = activities;
      
      if (activities.length === 0) {
        elements.activityList.innerHTML = '<p style="padding: 20px; text-align: center;">No activities found in this date range</p>';
        elements.activitySummary.innerHTML = '';
        return;
      }
      
      // Display activities with checkboxes
      const uniqueDays = new Set(
        activities.map(activity => {
          if (activity.start_date_local) {
            return activity.start_date_local.split('T')[0];
          }
          return new Date(activity.start_date).toISOString().split('T')[0];
        })
      );

      const dayCount = uniqueDays.size;
      const dayLabel = dayCount === 1 ? 'day' : 'days';
      const activityLabel = activities.length === 1 ? 'activity' : 'activities';

      elements.activitySummary.innerHTML = `
        <p style="margin: 10px 0;">
          <strong>${dayCount} ${dayLabel} in range</strong><br>
          <small>${activities.length} ${activityLabel} found</small>
        </p>
      `;

      const html = activities.map((activity) => {
        const date = new Date(activity.start_date).toLocaleDateString();
        const distance = (activity.distance / 1000).toFixed(2);
        const elevation = activity.total_elevation_gain ? Math.round(activity.total_elevation_gain) : 0;
        
        return `
          <div class="activity-item">
            <label>
              <input type="checkbox" value="${activity.id}" data-name="${activity.name}">
              <div>
                <strong>${activity.name}</strong><br>
                <small>${date} ‚Ä¢ ${distance} km ‚Ä¢ ${elevation}m elevation ‚Ä¢ ${activity.type}</small>
              </div>
            </label>
          </div>
        `;
      }).join('');
      
      elements.activityList.innerHTML = html;
      
    } catch (error) {
      console.error('Error loading activities:', error);
      elements.activityList.innerHTML = '<p style="padding: 20px; color: red;">Failed to load activities. Please try again.</p>';
    } finally {
      elements.loadingIndicator.classList.remove('active');
    }
  }

  // ============================================
  // MAP FUNCTIONS
  // ============================================
  
  /**
   * Initialize MapTiler map with terrain support
   */
  function initMap() {
    maptilersdk.config.apiKey = CONFIG.API_KEY;
    
    // Create map with current style
    state.map = new maptilersdk.Map({
      container: 'map',
      style: CONFIG.MAP_STYLES[state.currentMapStyle],
      center: [5.1214, 52.0907], // Soest, Utrecht, Netherlands
      zoom: 8,
      maxPitch: 85,
      antialias: true
    });
    
    // Prepare terrain-related controls after the style loads
    state.map.on('load', () => {
      console.log('Map loaded successfully');
      prepareTerrainSupport();
    });
    
    state.map.on('error', (e) => {
      console.error('Map error:', e);
    });
  }

  /**
   * Toggle between map styles while preserving routes and camera position
   */
  function toggleMapStyle() {
    const styles = Object.keys(CONFIG.MAP_STYLES);
    const currentIndex = styles.indexOf(state.currentMapStyle);
    const nextIndex = (currentIndex + 1) % styles.length;
    state.currentMapStyle = styles[nextIndex];
    
    // Save current camera state
    const currentCenter = state.map.getCenter();
    const currentZoom = state.map.getZoom();
    const currentBearing = state.map.getBearing();
    const currentPitch = state.map.getPitch();
    const wasTerrainEnabled = state.terrainEnabled;
    
    // Update button label
    const buttonLabels = {
      streets: 'üó∫Ô∏è Streets',
      vintage: 'üìú Vintage',
      satellite: 'üõ∞Ô∏è Satellite',
      topo: '‚õ∞Ô∏è Topo'
    };
    elements.toggleMapStyle.textContent = buttonLabels[state.currentMapStyle];
    
    // Apply new style
    state.map.setStyle(CONFIG.MAP_STYLES[state.currentMapStyle]);
    
    // Restore everything after style loads
    state.map.once('styledata', () => {
      // Restore camera position
      state.map.jumpTo({
        center: currentCenter,
        zoom: currentZoom,
        bearing: currentBearing,
        pitch: currentPitch
      });
      
      // Re-create terrain support and restore prior state
      state.terrainEnabled = wasTerrainEnabled;
      prepareTerrainSupport();
      
      // Re-add all routes
      state.routes.forEach(route => {
        if (!state.map.getSource(route.id)) {
          state.map.addSource(route.id, {
            type: 'geojson',
            data: {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: route.data.coordinates
              }
            }
          });
        }
        
        if (!state.map.getLayer(route.id)) {
          state.map.addLayer({
            id: route.id,
            type: 'line',
            source: route.id,
            paint: {
              'line-color': route.color,
              'line-width': 4,
              'line-opacity': 0.8
            }
          });
        }
      });
      
      console.log(`Switched to ${state.currentMapStyle} style`);
    });
  }

  /**
   * Ensure the DEM source required for terrain rendering exists
   */
  function ensureTerrainSource() {
    if (!state.map.getSource(CONFIG.TERRAIN.sourceId)) {
      try {
        state.map.addSource(CONFIG.TERRAIN.sourceId, {
          type: 'raster-dem',
          url: CONFIG.TERRAIN.sourceUrl,
          tileSize: 256,
          maxzoom: 12
        });
      } catch (error) {
        console.warn('Unable to add terrain source:', error);
      }
    }
  }

  /**
   * Attach a custom terrain toggle control without duplicating default buttons
   */
  function ensureTerrainToggleControl() {
    if (state.terrainToggleControl || typeof state.map.setTerrain !== 'function') {
      return;
    }

    class TerrainToggleControl {
      onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'vintage-terrain-toggle';
        this._container.classList.add('maplibregl-ctrl', 'maplibregl-ctrl-group', 'maptilersdk-ctrl', 'maptilersdk-ctrl-group');

        this._button = document.createElement('button');
        this._button.type = 'button';
        this._button.className = 'terrain-toggle-button';
        this._button.setAttribute('aria-label', 'Toggle 3D terrain');
        this._button.textContent = '3D';
        this._handler = () => toggleTerrain();
        this._button.addEventListener('click', this._handler);

        this._container.appendChild(this._button);
        return this._container;
      }

      onRemove() {
        if (this._button && this._handler) {
          this._button.removeEventListener('click', this._handler);
        }
        this._handler = undefined;
        this._container?.remove();
        this._map = undefined;
      }
    }

    state.terrainToggleControl = new TerrainToggleControl();
    state.map.addControl(state.terrainToggleControl, 'top-right');
    updateTerrainButtonState();
  }

  /**
   * Reflect the active terrain state in the toggle control
   */
  function updateTerrainButtonState() {
    const control = state.terrainToggleControl;
    if (!control || !control._button) return;

    control._button.classList.toggle('is-active', state.terrainEnabled);
    control._button.setAttribute('aria-pressed', state.terrainEnabled ? 'true' : 'false');
  }

  /**
   * Apply terrain changes to the map based on the current state
   */
  function applyTerrainState(options = {}) {
    if (!state.map || typeof state.map.setTerrain !== 'function') {
      state.terrainEnabled = false;
      updateTerrainButtonState();
      return;
    }

    if (state.terrainEnabled) {
      ensureTerrainSource();
      try {
        state.map.setTerrain({
          source: CONFIG.TERRAIN.sourceId,
          exaggeration: CONFIG.TERRAIN.exaggeration
        });
        if (typeof state.map.setFog === 'function') {
          state.map.setFog({});
        }
        if (options.animate) {
          state.map.easeTo({ pitch: Math.max(state.map.getPitch(), 60), duration: 1000 });
        }
      } catch (error) {
        console.warn('Unable to enable terrain:', error);
        state.terrainEnabled = false;
      }
    } else {
      try {
        state.map.setTerrain(null);
        if (typeof state.map.setFog === 'function') {
          state.map.setFog(null);
        }
        if (options.animate) {
          state.map.easeTo({ pitch: 0, duration: 1000 });
        }
      } catch (error) {
        console.warn('Unable to disable terrain:', error);
      }
    }

    updateTerrainButtonState();
  }

  /**
   * Toggle terrain state from the custom control
   */
  function toggleTerrain() {
    state.terrainEnabled = !state.terrainEnabled;
    applyTerrainState({ animate: true });
  }

  /**
   * Prepare terrain support (source + control) without duplicating UI
   */
  function prepareTerrainSupport() {
    if (!state.map) return;

    ensureTerrainSource();
    ensureTerrainToggleControl();
    applyTerrainState();
  }

  /**
   * Add a parsed GPX route to the map
   */
  function addRouteToMap(data) {
    if (state.routes.length >= CONFIG.MAX_ROUTES) {
      alert(`Maximum ${CONFIG.MAX_ROUTES} routes reached`);
      return;
    }
    
    const color = CONFIG.COLORS[state.colorIndex++ % CONFIG.COLORS.length];
    const sourceId = `route-${Date.now()}`;
    
    // Add route as GeoJSON source
    state.map.addSource(sourceId, {
      type: 'geojson',
      data: {
        type: 'Feature',
        geometry: {
          type: 'LineString',
          coordinates: data.coordinates
        }
      }
    });
    
    // Add line layer for the route
    state.map.addLayer({
      id: sourceId,
      type: 'line',
      source: sourceId,
      paint: {
        'line-color': color,
        'line-width': 4,
        'line-opacity': 0.8
      }
    });
    
    // Store route reference
    state.routes.push({
      id: sourceId,
      color: color,
      data: data
    });
    
    state.fileData.push(data);
    
    // Update cumulative statistics
    state.stats.totalDistance += Number.isFinite(data.totalDistance) ? data.totalDistance : 0;
    state.stats.totalClimb += Number.isFinite(data.climb) ? data.climb : 0;
    state.stats.totalDescent += Number.isFinite(data.descent) ? data.descent : 0;

    const routeDay = data.startDate || data.endDate || (data.startTime ? data.startTime.split('T')[0] : null);
    if (routeDay) {
      state.stats.days.add(routeDay);
    }
    
    if (!state.stats.startDate || data.startDate < state.stats.startDate) {
      state.stats.startDate = data.startDate;
    }
    if (!state.stats.endDate || data.endDate > state.stats.endDate) {
      state.stats.endDate = data.endDate;
    }
    
    // Fit map to show all routes
    const bounds = new maptilersdk.LngLatBounds();
    data.coordinates.forEach(coord => bounds.extend(coord));
    state.map.fitBounds(bounds, { padding: 50 });
    
    updateStats();
    updateTrailLabels();
    
    // Auto-draw elevation profile if visible
    if (elements.elevationProfile.style.display === 'block') {
      drawElevationProfile();
    }
  }
  
  // ============================================
  // UI UPDATE FUNCTIONS
  // ============================================
  
  /**
   * Update the statistics panel with current route data
   */
  function updateStats() {
    elements.stats.style.display = 'block';
    const dayCount = state.stats.days ? state.stats.days.size : 0;

    elements.statsContent.innerHTML = `
      <div class="stat-line">Days covered: ${dayCount}</div>
      <div class="stat-line">Routes loaded: ${state.routes.length}</div>
      <div class="stat-line">Distance: ${state.stats.totalDistance.toFixed(2)} km</div>
      <div class="stat-line">Climb: ${state.stats.totalClimb.toFixed(0)} m</div>
      <div class="stat-line">Descent: ${state.stats.totalDescent.toFixed(0)} m</div>
    `;
  }
  
  /**
   * Update the trail labels panel with route information
   */
  function updateTrailLabels() {
    const html = state.routes.map((route, i) => {
      const distance = Number.isFinite(route.data.totalDistance) ? route.data.totalDistance : 0;
      const climb = Number.isFinite(route.data.climb) ? route.data.climb : 0;
      const descent = Number.isFinite(route.data.descent) ? route.data.descent : 0;

      return `
        <div class="trail-label-item" style="border-left: 4px solid ${route.color}">
          <strong>${route.data.name || `Route ${i + 1}`}</strong><br>
          ${distance.toFixed(1)}km |
          ‚Üë${climb.toFixed(0)}m |
          ‚Üì${descent.toFixed(0)}m
        </div>
      `;
    }).join('');

    elements.trailLabelsContent.innerHTML = html;
  }

  function parseNumeric(value) {
    if (typeof value === 'number') {
      return Number.isFinite(value) ? value : NaN;
    }
    if (typeof value === 'string') {
      const parsed = parseFloat(value);
      return Number.isFinite(parsed) ? parsed : NaN;
    }
    return NaN;
  }

  function haversineDistance(lat1, lon1, lat2, lon2) {
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    return CONFIG.EARTH_RADIUS * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  function sanitizeProfilePoints(points) {
    return points
      .map((point) => ({
        distance: parseNumeric(point.distance),
        elevation: parseNumeric(point.elevation)
      }))
      .filter((point) => Number.isFinite(point.distance) && Number.isFinite(point.elevation))
      .sort((a, b) => a.distance - b.distance);
  }

  function buildProfileFromCoordinates(routeData) {
    if (!routeData) return [];

    const coords = Array.isArray(routeData.coordinates) ? routeData.coordinates : [];
    const elevations = Array.isArray(routeData.elevations) ? routeData.elevations : [];

    if (coords.length === 0 || elevations.length === 0) {
      return [];
    }

    const usableLength = Math.min(coords.length, elevations.length);
    if (usableLength < 2) {
      return [];
    }

    const points = [];
    let cumulativeDistance = 0;

    for (let i = 0; i < usableLength; i++) {
      const [lon, lat] = coords[i];
      const lonValue = parseNumeric(lon);
      const latValue = parseNumeric(lat);
      const elevation = parseNumeric(elevations[i]);

      if (!Number.isFinite(lonValue) || !Number.isFinite(latValue)) {
        continue;
      }

      if (i > 0) {
        const [prevLon, prevLat] = coords[i - 1];
        const prevLonValue = parseNumeric(prevLon);
        const prevLatValue = parseNumeric(prevLat);

        if (Number.isFinite(prevLonValue) && Number.isFinite(prevLatValue)) {
          const segment = haversineDistance(prevLatValue, prevLonValue, latValue, lonValue);
          if (Number.isFinite(segment)) {
            cumulativeDistance += segment;
          }
        }
      }

      if (Number.isFinite(elevation)) {
        points.push({
          distance: cumulativeDistance,
          elevation: elevation
        });
      }
    }

    return sanitizeProfilePoints(points);
  }

  function getRouteProfilePoints(routeData) {
    if (!routeData) {
      return [];
    }

    const fromProfile = Array.isArray(routeData.profile) ? sanitizeProfilePoints(routeData.profile) : [];
    if (fromProfile.length > 0) {
      return fromProfile;
    }

    const fromTrackPoints = Array.isArray(routeData.trackPoints) ? sanitizeProfilePoints(routeData.trackPoints) : [];
    if (fromTrackPoints.length > 0) {
      return fromTrackPoints;
    }

    return buildProfileFromCoordinates(routeData);
  }

  function getRouteDistance(routeData, profilePoints) {
    if (Array.isArray(profilePoints) && profilePoints.length > 0) {
      const lastPoint = profilePoints[profilePoints.length - 1];
      if (Number.isFinite(lastPoint.distance) && lastPoint.distance > 0) {
        return lastPoint.distance;
      }
    }

    if (routeData && Number.isFinite(routeData.totalDistance) && routeData.totalDistance > 0) {
      return routeData.totalDistance;
    }

    if (routeData && Array.isArray(routeData.trackPoints) && routeData.trackPoints.length > 0) {
      const lastTrackPoint = routeData.trackPoints[routeData.trackPoints.length - 1];
      if (lastTrackPoint) {
        const normalized = parseNumeric(lastTrackPoint.distance);
        if (Number.isFinite(normalized) && normalized > 0) {
          return normalized;
        }
      }
    }

    return null;
  }

  /**
   * FIX #2: Enhanced elevation profile with proper canvas sizing
   * Handles canvas dimensions correctly even when initially hidden
   */
  function drawElevationProfile() {
    const canvas = elements.elevationCanvas;
    const ctx = canvas.getContext('2d');

    if (!ctx) return;

    const wasHidden = elements.elevationProfile.style.display === 'none';
    if (wasHidden) {
      elements.elevationProfile.style.display = 'block';
    }

    void canvas.offsetHeight;

    const containerRect = elements.elevationProfile.getBoundingClientRect();
    const canvasWidth = Math.max((containerRect.width || 600) - 40, 200);
    const canvasHeight = 200;

    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.scale(dpr, dpr);

    const segments = [];
    let distanceOffset = 0;

    state.routes.forEach((route, index) => {
      const routeData = route.data || {};
      const profile = getRouteProfilePoints(routeData);

      if (profile.length > 0) {
        const points = profile.map(point => ({
          distance: point.distance + distanceOffset,
          elevation: point.elevation
        }));

        const color = route.color || CONFIG.COLORS[index % CONFIG.COLORS.length];
        segments.push({ color, points });
      }

      const segmentDistance = getRouteDistance(routeData, profile);
      if (Number.isFinite(segmentDistance) && segmentDistance > 0) {
        distanceOffset += segmentDistance;
      }
    });

    const allPoints = segments.flatMap(segment => segment.points);

    if (allPoints.length === 0) {
      ctx.fillStyle = '#654321';
      ctx.font = '14px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText('Load activities to see elevation profile', canvasWidth / 2, canvasHeight / 2);
      return;
    }

    if (allPoints.length < 2) {
      ctx.fillStyle = '#654321';
      ctx.font = '14px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText('Not enough elevation data to draw profile', canvasWidth / 2, canvasHeight / 2);
      return;
    }

    const minElevation = Math.min(...allPoints.map(point => point.elevation));
    const maxElevation = Math.max(...allPoints.map(point => point.elevation));
    const maxDistance = Math.max(...allPoints.map(point => point.distance));

    if (!Number.isFinite(minElevation) || !Number.isFinite(maxElevation) || !Number.isFinite(maxDistance)) {
      ctx.fillStyle = '#654321';
      ctx.font = '14px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText('Elevation data incomplete', canvasWidth / 2, canvasHeight / 2);
      return;
    }

    if (maxDistance <= 0) {
      ctx.fillStyle = '#654321';
      ctx.font = '14px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText('Elevation profile requires distance data', canvasWidth / 2, canvasHeight / 2);
      return;
    }

    const margin = { top: 20, right: 30, bottom: 40, left: 60 };
    const graphWidth = canvasWidth - margin.left - margin.right;
    const graphHeight = canvasHeight - margin.top - margin.bottom;

    if (graphWidth <= 0 || graphHeight <= 0) {
      return;
    }

    let elevationPadding = (maxElevation - minElevation) * 0.1;
    if (!Number.isFinite(elevationPadding) || elevationPadding === 0) {
      elevationPadding = 10;
    }

    const elevationMin = minElevation - elevationPadding;
    const elevationMax = maxElevation + elevationPadding;

    const xScale = (distance) => margin.left + (distance / maxDistance) * graphWidth;
    const yScale = (elevation) => margin.top + graphHeight - ((elevation - elevationMin) / (elevationMax - elevationMin)) * graphHeight;

    ctx.fillStyle = '#fffdf7';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const numXGridLines = 5;
    const numYGridLines = 5;

    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;

    for (let i = 0; i <= numXGridLines; i++) {
      const x = margin.left + (i / numXGridLines) * graphWidth;
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, margin.top + graphHeight);
      ctx.stroke();
    }

    for (let i = 0; i <= numYGridLines; i++) {
      const y = margin.top + (i / numYGridLines) * graphHeight;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + graphWidth, y);
      ctx.stroke();
    }

    ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
    ctx.beginPath();
    allPoints.forEach((point, index) => {
      const x = xScale(point.distance);
      const y = yScale(point.elevation);
      if (index === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    const lastPoint = allPoints[allPoints.length - 1];
    ctx.lineTo(xScale(lastPoint.distance), margin.top + graphHeight);
    ctx.lineTo(xScale(allPoints[0].distance), margin.top + graphHeight);
    ctx.closePath();
    ctx.fill();

    segments.forEach(segment => {
      if (segment.points.length < 2) return;
      ctx.beginPath();
      segment.points.forEach((point, index) => {
        const x = xScale(point.distance);
        const y = yScale(point.elevation);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.strokeStyle = segment.color || '#8b4513';
      ctx.lineWidth = 2;
      ctx.stroke();
    });

    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top + graphHeight);
    ctx.lineTo(margin.left + graphWidth, margin.top + graphHeight);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + graphHeight);
    ctx.stroke();

    ctx.fillStyle = '#654321';
    ctx.font = '11px Georgia, serif';
    ctx.textAlign = 'center';

    for (let i = 0; i <= numXGridLines; i++) {
      const distance = (maxDistance / numXGridLines) * i;
      const x = margin.left + (i / numXGridLines) * graphWidth;
      const y = margin.top + graphHeight + 20;
      ctx.fillText(`${distance.toFixed(1)} km`, x, y);
    }

    ctx.fillText('Distance', margin.left + graphWidth / 2, canvasHeight - 5);

    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';

    for (let i = 0; i <= numYGridLines; i++) {
      const elevation = elevationMin + ((elevationMax - elevationMin) / numYGridLines) * (numYGridLines - i);
      const x = margin.left - 10;
      const y = margin.top + (i / numYGridLines) * graphHeight;
      ctx.fillText(`${Math.round(elevation)} m`, x, y);
    }

    ctx.save();
    ctx.translate(15, margin.top + graphHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillText('Elevation', 0, 0);
    ctx.restore();

    const highestPoint = allPoints.reduce((prev, current) => current.elevation > prev.elevation ? current : prev);
    const lowestPoint = allPoints.reduce((prev, current) => current.elevation < prev.elevation ? current : prev);

    ctx.font = 'bold 10px Georgia, serif';
    ctx.textAlign = 'left';

    ctx.fillStyle = '#8b0000';
    const highX = xScale(highestPoint.distance);
    const highY = yScale(highestPoint.elevation);
    ctx.beginPath();
    ctx.arc(highX, highY, 3, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText(`‚ñ≤ ${Math.round(highestPoint.elevation)}m`, highX + 5, highY - 5);

    ctx.fillStyle = '#2d5016';
    const lowX = xScale(lowestPoint.distance);
    const lowY = yScale(lowestPoint.elevation);
    ctx.beginPath();
    ctx.arc(lowX, lowY, 3, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText(`‚ñº ${Math.round(lowestPoint.elevation)}m`, lowX + 5, lowY + 10);

    console.log(`Elevation profile drawn: ${allPoints.length} points, ${maxDistance.toFixed(1)} km`);
  }

    
  // ============================================
  // EVENT LISTENERS
  // ============================================
  
  function setupEventListeners() {
    // GPX file upload
    elements.gpxInput.addEventListener('change', (e) => {
      Array.from(e.target.files).forEach(file => {
        const reader = new FileReader();
        reader.onload = (event) => {
          const xml = new DOMParser().parseFromString(event.target.result, 'text/xml');
          const parser = new GPXParser(xml, file.name);
          const data = parser.parse();
          if (data.coordinates.length > 0) {
            addRouteToMap(data);
          }
        };
        reader.readAsText(file);
      });
    });
    
    // Clear all routes
    elements.clearBtn.addEventListener('click', () => {
      if (confirm('Clear all routes?')) {
        state.routes.forEach(route => {
          state.map.removeLayer(route.id);
          state.map.removeSource(route.id);
        });
        state.routes = [];
        state.fileData = [];
        state.colorIndex = 0;
        state.stats = {
          totalDistance: 0,
          totalClimb: 0,
          totalDescent: 0,
          startDate: null,
          endDate: null,
          days: new Set()
        };
        updateStats();
        updateTrailLabels();
        elements.stats.style.display = 'none';
        elements.elevationProfile.style.display = 'none';
        elements.trailLabels.style.display = 'none';
      }
    });
    
    // Map control buttons
    elements.fullscreenBtn.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.getElementById('map').requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
    
    elements.toggleElevation.addEventListener('click', () => {
      const visible = elements.elevationProfile.style.display === 'block';
      elements.elevationProfile.style.display = visible ? 'none' : 'block';

      if (!visible) {
        setTimeout(() => drawElevationProfile(), 50);
      }
    });
    
    elements.toggleStats.addEventListener('click', () => {
      const visible = elements.stats.style.display === 'block';
      elements.stats.style.display = visible ? 'none' : 'block';
    });
    
    elements.toggleLabels.addEventListener('click', () => {
      const visible = elements.trailLabels.style.display === 'block';
      elements.trailLabels.style.display = visible ? 'none' : 'block';
    });
    
    // Map style toggle
    elements.toggleMapStyle.addEventListener('click', toggleMapStyle);
    
    // Strava activity controls
    elements.loadDateRange.addEventListener('click', loadActivitiesForDateRange);
    elements.loadSelected.addEventListener('click', loadSelectedActivities);
    
    elements.selectAll.addEventListener('click', () => {
      document.querySelectorAll('#activityList input[type="checkbox"]').forEach(cb => {
        cb.checked = true;
      });
    });
    
    elements.selectNone.addEventListener('click', () => {
      document.querySelectorAll('#activityList input[type="checkbox"]').forEach(cb => {
        cb.checked = false;
      });
    });
    
    // Strava connection status
    updateStravaButtons();
    
    // Redraw elevation profile on window resize
    window.addEventListener('resize', () => {
      if (elements.elevationProfile.style.display === 'block') {
        drawElevationProfile();
      }
    });
  }
  
  /**
   * Update Strava connection buttons based on authentication status
   */
  function updateStravaButtons() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('connected') === 'true') {
      state.stravaConnected = true;
      window.history.replaceState({}, document.title, window.location.pathname);
    }
    
    if (state.stravaConnected) {
      elements.stravaButtons.innerHTML = `
        <button class="btn strava" onclick="document.getElementById('activitySelector').style.display='block'">Select Activities</button>
        <button class="btn" onclick="location.href='strava-disconnect.php'">Disconnect</button>
      `;
      elements.activitySelector.style.display = 'block';
    } else {
      elements.stravaButtons.innerHTML = `
        <button class="btn strava" onclick="location.href='strava-auth.php'">Connect with Strava</button>
      `;
    }
  }
  
  // ============================================
  // INITIALIZATION
  // ============================================
  
  function init() {
    // Cache DOM elements
    ['gpxInput', 'clearBtn', 'loadingIndicator', 'stats', 'statsContent',
     'elevationProfile', 'elevationCanvas', 'trailLabels', 'trailLabelsContent',
     'fullscreenBtn', 'toggleElevation', 'toggleStats', 'toggleLabels', 'toggleMapStyle',
     'stravaButtons', 'activitySelector', 'activityList', 'activitySummary',
     'loadSelected', 'selectAll', 'selectNone', 'startDate', 'endDate',
     'loadDateRange'].forEach(id => {
      elements[id] = document.getElementById(id);
    });
    
    initMap();
    setupEventListeners();
    
    // Set default date range to June 2024
    elements.startDate.value = '2024-06-01';
    elements.endDate.value = '2024-06-30';
  }
  
  return {
    init: init
  };
})();

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', StravaMapApp.init);
} else {
  StravaMapApp.init();
}
</script>

<!-- Sequential activity loading fix -->
<script src="strava-fix.js"></script>
</body>
</html>
